============================= test session starts ==============================
platform linux -- Python 3.6.0, pytest-3.0.6, py-1.4.32, pluggy-0.4.0
rootdir: /home/workspace/the-mystery-machine/tree_search, inifile: 
collected 31 items

test_methods.py .....................
test_search.py ......
test_tree.py ..FF

=================================== FAILURES ===================================
________________________ TestNode.test_expand_all_edges ________________________

self = <test_tree.TestNode object at 0xb6588f4c>

    def test_expand_all_edges(self):
        """
            Tests if expand all children adds all story nodes
            """
        root = State(ACTORS, PLACES, ITEMS)
        node = TreeNode(root)
        num_total_actions = len(node.possible_methods)
>       expand_all_edges(node)

test_tree.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tree.py:65: in expand_all_edges
    expand_edge(node)
tree.py:52: in expand_edge
    new_edge(node)
tree.py:34: in __call__
    self.method(node.state)
methods.py:62: in __call__
    self.sentence, self.believability = self.method(self.next_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actor_a_key = 'BOB', actor_b_key = 'CHARLIE'
state = <setup.State object at 0xb65292ac>

    def mug(actor_a_key, actor_b_key, state):
        """
        description: actor_a mugs an item from actor_b
        precondition: actor_a must be alive, actor_b must
            have items that can be stolen
        postcondition: actor_b loses a random item and actor_a gains it, actor_b
            becomes angrier at actor_a
        """
    
        actor_a = state.actors[actor_a_key]
        actor_b = state.actors[actor_b_key]
    
        if (len(actor_b["items"]) == 0):
            sentence = "Nonsense Sentence. "
            believability = 0
            return (sentence, believability)
    
        rand_idx = randint(0, len(actor_b["items"]) - 1)
        actor_b_item = actor_b["items"].pop(rand_idx)
        actor_a["items"].append(actor_b_item)
        if actor_a_key in actor_b["kill_desire"]:
            actor_b["kill_desire"][actor_a_key] = rectadd( actor_b["kill_desire"][actor_a_key],  METHOD_CONSTANTS[ "MUG_KILL_DESIRE_INC" ] )
        else:
            actor_b["kill_desire"][actor_a_key] = METHOD_CONSTANTS[ "MUG_KILL_DESIRE_INC" ]
    
        if actor_a_key in actor_b["affection"]:
            actor_b["affection"][actor_a_key][0] = METHOD_CONSTANTS[ "MUG_AFFECTION" ]
        else:
            actor_b["affection"][actor_a_key] = ( METHOD_CONSTANTS[ "MUG_AFFECTION" ], RELATIONSHIPS[ "STRANGER" ] )
    
>       actor_b["grief"] = rectadd( actor_b["grief"], actor_b_item["value"] / 2 )
E       KeyError: 'grief'

methods.py:123: KeyError
____________________ TestEdge.test_edges_point_to_new_node _____________________

self = <test_tree.TestEdge object at 0xb664b6cc>

    def test_edges_point_to_new_node(self):
        """
            Tests if expanded edges point to new nodes
            """
        root = State(ACTORS, PLACES, ITEMS)
        node = TreeNode(root)
>       expand_all_edges(node)

test_tree.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tree.py:65: in expand_all_edges
    expand_edge(node)
tree.py:52: in expand_edge
    new_edge(node)
tree.py:34: in __call__
    self.method(node.state)
methods.py:62: in __call__
    self.sentence, self.believability = self.method(self.next_state)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

actor_a_key = 'BOB', actor_b_key = 'CHARLIE'
state = <setup.State object at 0xb656c7cc>

    def mug(actor_a_key, actor_b_key, state):
        """
        description: actor_a mugs an item from actor_b
        precondition: actor_a must be alive, actor_b must
            have items that can be stolen
        postcondition: actor_b loses a random item and actor_a gains it, actor_b
            becomes angrier at actor_a
        """
    
        actor_a = state.actors[actor_a_key]
        actor_b = state.actors[actor_b_key]
    
        if (len(actor_b["items"]) == 0):
            sentence = "Nonsense Sentence. "
            believability = 0
            return (sentence, believability)
    
        rand_idx = randint(0, len(actor_b["items"]) - 1)
        actor_b_item = actor_b["items"].pop(rand_idx)
        actor_a["items"].append(actor_b_item)
        if actor_a_key in actor_b["kill_desire"]:
            actor_b["kill_desire"][actor_a_key] = rectadd( actor_b["kill_desire"][actor_a_key],  METHOD_CONSTANTS[ "MUG_KILL_DESIRE_INC" ] )
        else:
            actor_b["kill_desire"][actor_a_key] = METHOD_CONSTANTS[ "MUG_KILL_DESIRE_INC" ]
    
        if actor_a_key in actor_b["affection"]:
            actor_b["affection"][actor_a_key][0] = METHOD_CONSTANTS[ "MUG_AFFECTION" ]
        else:
            actor_b["affection"][actor_a_key] = ( METHOD_CONSTANTS[ "MUG_AFFECTION" ], RELATIONSHIPS[ "STRANGER" ] )
    
>       actor_b["grief"] = rectadd( actor_b["grief"], actor_b_item["value"] / 2 )
E       KeyError: 'grief'

methods.py:123: KeyError
===================== 2 failed, 29 passed in 0.47 seconds ======================
